-- 10 Advanced Business Problems
-- ---------------------------

/*
1. Top Selling Products
Query the top 10 products by total sales value.
Challenge: Include product name, total quantity sold, and total sales value.
*/

--  add column 
alter table order_items
add total_sales float ;

update order_items
set total_sales = quantity * price_per_unit ;

SELECT * FROM order_items;

select p.product_id, 
p.product_name, sum(oi.quantity) as total_quantity_sold,
round(sum(oi.total_sales ),2) as total_sales
from products p
join order_items oi
on p.product_id = oi.product_id 
group by p.product_id ,p.product_name 
order by total_sales desc 
limit 10 ;

/*
2. Revenue by Category
Calculate total revenue generated by each product category.
Challenge: Include the percentage contribution of each category to total revenue.
*/

select sum(total_sales)  as total_revenue from order_items ;

SELECT 
	c.category_id,
	c.category_name,
	round(SUM(oi.total_sales),2) as revenue,
    round((select sum(total_sales) from order_items ),2) as total_revenue,
	round((SUM(oi.total_sales)/(select sum(total_sales) from order_items ))*100,2) as contribution
FROM order_items as oi
JOIN products as p
ON p.product_id = oi.product_id
JOIN category as c
ON c.category_id = p.category_id
GROUP BY c.category_id, c.category_name ;

/*
3. Average Order Value (AOV)
Compute the average order value for each customer.
Challenge: Include only customers with more than 5 orders.
*/
-- average order value =  total amount they spent on complete order / how many orders they have done

-- eg- rahul has done 2 orders and in these 2 orders he purchase 5 items and
--  total he give 1000 of these 2 orders. But we do not have to focus on itmes in these 2 orders 
-- so avg rahul spent = 1000 / 2  

alter table customers
add full_name varchar(30) ;

update customers
set full_name = CONCAT(first_name, ' ', last_name) ;

SELECT * FROM customers;

select c.customer_id, c.full_name, count(od.order_id) as total_orders,
round(sum(oi.total_sales)/count(od.order_id), 2) as average_order_value
from customers c
join orders od
on c.customer_id = od.customer_id 
join order_items oi
on od.order_id = oi.order_id
group by c.customer_id, c.full_name
having count(od.order_id)>5;

/*
4. Monthly Sales Trend
Query monthly total sales over the past year.
Challenge: Display the sales trend, grouping by month, return current_month sale, last month sale!
*/
-- Take interval 2 year because order_date is upto 2024-7-24 
select current_date() - interval 2 year ; -- 2023-07-24

select *, 
lag(current_month_sale) over(order by year, month)  as last_month_sale 
from  (
select year(od.order_date) as year , month(od.order_date) as month,
round(sum(oi.total_sales),2) as current_month_sale
from orders od
join order_items oi
on od.order_id= oi.order_id
where od.order_date >= curdate() - interval 2 year
group by year(od.order_date), month(od.order_date) ) as t1 ;

/*
5. Customers with No Purchases
Find customers who have registered but never placed an order.
Challenge: List customer details and the time since their registration.
*/
select *                              -- reg_date - CURRENT_DATE
from customers 
where customer_id not in
(select distinct customer_id from orders) ;

select c.*  from  customers c
left join orders od 
on c.customer_id = od.customer_id 
where od.customer_id is null ;

/*
6. Least-Selling Categories by State
Identify the Least-selling product category for each state.
Challenge: Include the total sales for that category within each state.
*/
-- category, state, total sales --- best means high sales 


select state, category_name, round(sales,2) as total_sales  
from 
(
select cu.state, c.category_name, sum(od.total_sales) as sales,
rank() over(partition by cu.state order by sum(od.total_sales) asc ) as rnk 
from category c
join products p
on p.category_id = c.category_id 
join order_items od
on p.product_id = od.product_id 
join orders o
on o.order_id = od.order_id 
join customers cu
on o.customer_id = cu.customer_id 
group by cu.state, c.category_name 
) as t1
where rnk = 1 ;

/*
7. Customer Lifetime Value (CLTV)  ----total sales 
Calculate the total value of orders placed by each customer over their lifetime.
Challenge: Rank customers based on their CLTV.
*/

select c.customer_id, c.full_name, round(sum(od.total_sales),2) as cltv,
dense_rank() over(order by sum(od.total_sales) desc ) as rnk
from orders o
join order_items od 
on o.order_id = od.order_id 
join customers c
on o.customer_id= c.customer_id
group by c.customer_id, c.full_name ;

/*
8. Inventory Stock Alerts
Query products with stock levels below a certain threshold (e.g., less than 10 units).
Challenge: Include last restock date and warehouse information.
*/

select p.product_name, i.inventory_id, i.stock as current_stock_left,
i.warehouse_id, i.last_stock_date
from products p
join inventory i 
on p.product_id = i.product_id
where stock<10  ;

/*
9. Shipping Delays
Identify orders where the shipping date is later than 3 days after the order date.
Challenge: Include customer, order details, and delivery provider.
*/

select c.customer_id, c.full_name, c.state, 
od.order_id, od.order_date, od.seller_id, od.order_status,
s.shipping_id, s.shipping_date, s.shipping_providers
from customers c
join orders od
on c.customer_id = od.customer_id
join shipping s
on od.order_id = s.order_id 
where datediff(s.shipping_date , od.order_date) > 3;

/*
10. Payment Success Rate 
Calculate the percentage of successful payments across all orders.
Challenge: Include breakdowns by payment status (e.g., failed, pending).
*/

select payment_status,  count(*) as total_payments_succesed,
(count(*)/(select count(*) from payments))*100  as percentage 
from payments
where payment_status = 'Payment Successed'
group by payment_status ;

      -- OR
      
select payment_status, cnt, pcnt as percentage 
from(
select payment_status, count(*) as cnt,  
(count(*)/(select count(*) from payments))*100  as pcnt
from payments
group by payment_status) as t1 
where payment_status = 'Payment Successed';


/*
11. Top Performing Sellers
Find the top 5 sellers based on total sales value.
Challenge: Include both successful and failed orders, and display their percentage of successful orders.
*/

with top_sellers as (
select s.seller_id, s.seller_name, round(sum(total_sales),2)  as total_sale
from orders od 
join order_items oi 
on od.order_id = oi.order_id
join sellers s
on od.seller_id = s.seller_id
group by s.seller_id, s.seller_name 
order by total_sale desc
limit 5 ),

sellers_reports as(
select od.seller_id, ts.seller_name, od.order_status, count(*)  as no_of_orders,
sum(count(*)) over(partition by seller_id) as total_orders ,
(count(*)/sum(count(*)) over(partition by seller_id))*100 as successful_orders_percentage
from orders od
join top_sellers ts
on od.seller_id = ts.seller_id
where order_status not in ('Inprogress', 'Returned')
group by od.seller_id, ts.seller_name, od.order_status ) 

select * from sellers_reports 
where order_status = 'completed' ;

         -- OR 
         
with top_sellers as (
select s.seller_id, s.seller_name, round(sum(total_sales),2)  as total_sale
from orders od 
join order_items oi 
on od.order_id = oi.order_id
join sellers s
on od.seller_id = s.seller_id
group by s.seller_id, s.seller_name 
order by total_sale desc
limit 5 ),

sellers_reports as(
select od.seller_id, ts.seller_name, od.order_status, count(*)  as no_of_orders
from orders od
join top_sellers ts
on od.seller_id = ts.seller_id
where order_status not in ('Inprogress', 'Returned')
group by od.seller_id, ts.seller_name, od.order_status ) 

select seller_id, seller_name,
sum(CASE WHEN order_status = 'Completed' THEN no_of_orders ELSE 0 END)  as completed_orders,
sum(CASE WHEN order_status = 'Cancelled' THEN no_of_orders ELSE 0 END)  as Cancelled_orders,
sum(no_of_orders) as total_orders,
sum(CASE WHEN order_status = 'Completed' THEN no_of_orders ELSE 0 END)/ sum(no_of_orders) *100 as successful_orders_percentage
from sellers_reports
group by seller_id, seller_name ;

/*
12. Product Profit Margin
Calculate the profit margin for each product (profit = difference between price and cost of goods sold).
Challenge: Rank products by their profit margin, showing highest to lowest.
*/
-- profit = total_sales - cogs * quantity 
-- profit_margin =  profit/total_sales * 100

select product_id, product_name, profit_margin ,
rank() over(order by profit_margin desc ) as rnk
from (
select p.product_id, p.product_name , 
sum(od.total_sales-p.cogs*od.quantity) as profit ,
(sum(od.total_sales-p.cogs*od.quantity)/sum(od.total_sales))*100  as profit_margin 
from products p
join order_items od
on p.product_id = od.product_id 
group by p.product_id, p.product_name ) as t1 ;
 
/*
13. Most Returned Products
Query the top 10 products by the number of returns.
Challenge: Display the return rate as a percentage of total units sold for each product.
*/

-- total units sold =  total no of orders 
--  number of returns = no of times every products returns
--  return_percentage = no of returns / total orders

select p.product_id , p.product_name , count(*) as total_units_sold ,
SUM(CASE WHEN od.order_status='returned' THEN 1 ELSE 0 END) as no_of_return ,
(SUM(CASE WHEN od.order_status='returned' THEN 1 ELSE 0 END)/count(*))*100 as return_percentage
from orders od
join order_items oi
on od.order_id = oi.order_id 
join products p 
on oi.product_id = p.product_id
group by p.product_id , p.product_name
order by no_of_return desc
limit 10 ;

/*
14. Orders Pending Shipment
Find orders that have been paid but are still pending shipment.
Challenge: Include order details, payment date, and customer information.
*/

select c.full_name as customer_name, od.order_id, od.order_status,
p.payment_date, p.payment_status
from customers c
join orders od
on c.customer_id = od.customer_id
join payments p
on od.order_id = p.order_id
where p.payment_status = 'payment successed' and od.order_status = 'inprogress';

/*
15. Inactive Sellers
Identify sellers who haven’t made any sales in the last 6 months.
Challenge: Show the last sale date and total sales from those sellers.
*/
-- for last 6 month = current_date()-interval 6 month & after -6 we get 2025-01-25
--  but the date is only upto 2024-07-30 
-- so we have to do current_date()-interval 1 year 6 month 

SELECT current_date()- interval 1 year - interval 6 month ;
          -- or  
SELECT DATE_SUB(CURDATE(), INTERVAL 18 MONTH) AS result_date;

with ct1 as (
select * from sellers
where seller_id not in 
(select seller_id from orders where order_date>=current_date()- interval 1 year - interval 6 month)
) 
select od.seller_id, max(od.order_date) as last_sale_date , 
max(oi.total_sales) as last_total_sales
from ct1 
join orders od
on ct1.seller_id = od.seller_id
join order_items oi
on od.order_id = oi.order_id 
group by ct1.seller_id ;

/*
16. IDENTITY customers into returning or new
if the customer has done more than 5 return categorize them as returning otherwise new
Challenge: List customers id, name, total orders, total returns
*/

select customer_id, full_name as customer_name, total_orders, total_returns ,
(CASE WHEN total_returns > 5 Then 'returning' ELSE 'new' END) as identity_customers
from (
select c.customer_id, c.full_name, count(order_id) as total_orders ,
sum(CASE 
    WHEN od.order_status='returned' Then 1 
    Else 0
END ) as total_returns
from customers c
join orders od
on c.customer_id = od.customer_id
group by c.customer_id, c.full_name ) as t1 ;

/*
17. Top 5 Customers by Orders in Each State
Identify the top 5 customers with the highest number of orders for each state.
Challenge: Include the number of orders and total sales for each customer.
*/

select state, full_name as customer_name, total_orders, total_sales
from (
select c.state, c.full_name, 
count(od.order_id) as total_orders, sum(oi.total_sales) as total_sales,
dense_rank() over(partition by c.state order by count(od.order_id) desc) as rnk
from customers c
join orders od
on c.customer_id = od.customer_id
join order_items oi
on od.order_id = oi.order_id 
group by c.state, c.full_name ) as t1 
where rnk <= 5 ;

/*
18. Revenue by Shipping Provider
Calculate the total revenue handled by each shipping provider.
Challenge: Include the total number of orders handled and 
the average delivery time for each provider.
*/
-- delivery time = return date - shipping date

select s.shipping_providers, count(od.order_id) as total_orders, 
round(sum(oi.total_sales),2) as revenue,
coalesce(AVG(s.return_date - s.shipping_date),0) as avg_delivery_time 
from shipping s
join orders od
on s.order_id = od.order_id
join order_items oi
on od.order_id = oi.order_id
group by s.shipping_providers ;

/*
19. Top 10 product with highest decreasing revenue ratio compare to last year(2022) and current_year(2023)
Challenge: Return product_id, product_name, category_name, 2022 revenue and 2023 revenue decrease ratio. At the end Round the result .
Note: Decrease ratio = cr-ls/ls* 100 (cr = current_year, ls=last_year)
*/

WITH last_year_sale as
(
SELECT 
	p.product_id, p.product_name, c.category_name,
	SUM(oi.total_sales) as revenue
FROM orders as o
JOIN order_items as oi
ON oi.order_id = o.order_id
JOIN products as p
ON p.product_id = oi.product_id
join category c
on p.category_id = c.category_id
WHERE YEAR(o.order_date) = 2022
GROUP BY p.product_id, p.product_name, c.category_name
),
current_year_sale AS
(
SELECT 
	p.product_id, p.product_name, c.category_name,
	SUM(oi.total_sales) as revenue
FROM orders as o
JOIN order_items as oi
ON oi.order_id = o.order_id
JOIN products as p
ON p.product_id = oi.product_id
join category c
on p.category_id = c.category_id
WHERE YEAR(o.order_date) = 2023
GROUP BY p.product_id, p.product_name, c.category_name
)
SELECT
	cs.product_id, cs.product_name, cs.category_name,
	ls.revenue as last_year_revenue,
	cs.revenue as current_year_revenue,
	ls.revenue - cs.revenue as rev_diff,
	ROUND((cs.revenue - ls.revenue) /ls.revenue * 100, 2) as reveneue_dec_ratio
FROM last_year_sale as ls
JOIN current_year_sale as cs
ON ls.product_id = cs.product_id
WHERE ls.revenue > cs.revenue
order by reveneue_dec_ratio 
limit 10 ;

/*
20. Final Task
-- Store Procedure
create a function as soon as the product is sold the same quantity should reduced from inventory table
after adding any sales records it should update the stock in the inventory table based on the product and qty purchased .
-- 
*/

DELIMITER //

CREATE PROCEDURE add_sales (
    IN p_order_id INT,
    IN p_customer_id INT,
    IN p_seller_id INT,
    IN p_order_item_id INT,
    IN p_product_id INT,
    IN p_quantity INT
)
BEGIN
    DECLARE v_count INT ;
    DECLARE v_price FLOAT ;
    DECLARE v_product VARCHAR(50);

    -- Fetch price and product name
    SELECT price, product_name
    INTO v_price, v_product
    FROM products
    WHERE product_id = p_product_id;

    -- Check stock
    SELECT COUNT(*)
    INTO v_count
    FROM inventory
    WHERE product_id = p_product_id
      AND stock >= p_quantity ;

    IF v_count > 0 THEN
        -- Insert into orders table
        INSERT INTO orders (order_id, order_date, customer_id, seller_id)
        VALUES (p_order_id, CURDATE(), p_customer_id, p_seller_id) ;

        -- Insert into order_items table
        INSERT INTO order_items (order_item_id, order_id, product_id, quantity, price_per_unit, total_sales)
        VALUES (p_order_item_id, p_order_id, p_product_id, p_quantity, v_price, v_price * p_quantity) ;

        -- Update inventory
        UPDATE inventory
        SET stock = stock - p_quantity
        WHERE product_id = p_product_id;

        -- Success message (for debugging purposes)
        SELECT CONCAT('Thank you, product "', v_product, '" sale has been added. Inventory updated.') AS message ;

    ELSE
        -- Stock not available message
        SELECT CONCAT('Product "', v_product, '" is not available or out of stock.') AS message ;
        
    END IF ;
    
END //

DELIMITER ;

call new_sales(25006, 3, 4, 21630 , 2, 30 ) ;
call new_sales(25007, 3, 4, 21631 , 3, 93 ) ;


 -- (
-- p_order_id INT,
-- p_customer_id INT,
-- p_seller_id INT,
-- p_order_item_id INT,
-- p_product_id INT,
-- p_quantity INT )
